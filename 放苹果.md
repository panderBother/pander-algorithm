> [放苹果](https://www.nowcoder.com/practice/bfd8234bb5e84be0b493656e390bdebf?tpId=386&tqId=36885&sourceUrl=%2Fexam%2Foj)（来源牛客（nowcoder））

> ## 描述
>
> 我们需要将 𝑚*m* 个相同的苹果放入 𝑛*n* 个相同的盘子中，允许有的盘子空着不放。求解有多少种不同的分法。
>
> ### 输入描述：
>
> 输入两个整数 𝑚,𝑛(0≦𝑚≦10; 1≦𝑛≦10)*m*,*n*(0≦*m*≦10; 1≦*n*≦10) 代表苹果数、盘子数。
>
> ### 输出描述：
>
> 输出一个整数，代表不同的分法数量。
>
> 输入：3 2
>
> 输出 2
>
> 输入：7 3
>
> 输出： 8

> 用递归的方法来写
>
> 当就有一个盘子时就一种方法；
>
> 当苹果的个数小于盘子时，每多一个盘子分法就多一；
>
> 当苹果个数大于 盘子时递归计算剩余数值(a-i)拆分成i个盘子的方式
>
> ```java
> 
> import java.util.Scanner;
> 
> // 注意类名必须为 Main, 不要有任何 package xxx 信息
> public class Main {
>     public static void main(String[] args) {
>         Scanner in = new Scanner(System.in);
>         // 注意 hasNext 和 hasNextLine 的区别
>         while (in.hasNextInt()) { // 注意 while 处理多个 case
>             int a = in.nextInt();
>             int b = in.nextInt();
>             System.out.println(solve(a,b));
>         }
>     }
>     public static int solve(int a,int b){
>         int c=0;
>         if(b==1){
>             return 1;
>         }
>         for(int i=1;i<=b;i++){
>             if(a<=i){
>                 c+=1;
>                 break;
>             }else{
>                 c+=solve(a-i,i);
>             }
>         }
>         return c;
>     }
> }
> ```

方法二、动态规划，

> - 当苹果数 < 盘子数，有空盘，则忽略一个盘子，在n-1个放苹果，一直递推到n==1，有一种摆法
> - 苹果数 >= 盘子数，可以看作没有空盘。则可以选择忽略一个盘子，如上边做法。还可以选择每个盘子放一个苹果，即苹果数剩下i-j,继续递推直到j==1

> ```java
> import java.util.*;
> public class Main {
>     public static void main(String[] args) {
>         Scanner scanner = new Scanner(System.in);
>         while (scanner.hasNext()){
>         	int m = scanner.nextInt();
>         	int n = scanner.nextInt();
>         	System.out.println(count(m, n));
>         }
>     }
> 
>     private static int count(int m, int n) {
>         // 持有i个苹果，有j个盘子可以存放苹果，总共有 dp[i][j]种方法
>         int[][] dp = new int[m+1][n+1];
>         // base case：没有苹果，只有一种摆放方法，可以作为下面递推的终止结果
>         for(int j = 0; j <= n; j++) {
>             dp[0][j] = 1;
>         }
>         for(int i = 1; i <= m; i++) {
>             for(int j = 1; j <= n; j++) {
>                 if(i < j) {
>                     // 苹果数 < 盘子数，有空盘，
>                     // 则忽略一个盘子，在n-1个放苹果，一直递推到n==1，有一种摆法
>                     dp[i][j] = dp[i][j-1];
>                 } else {
>                     // 苹果数 >= 盘子数，可以看作没有空盘
>                     // 则可以选择忽略一个盘子，如上边做法
>                     // 还可以选择每个盘子放一个苹果，即苹果数剩下i-j,继续递推直到j==1
>                     dp[i][j] = dp[i][j-1] + dp[i-j][j];
>                 }
>             }
>         }
>         return dp[m][n];
>     }
> }
>         
> 
> ```
>
> 