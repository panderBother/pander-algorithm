> [子数列求积](https://www.nowcoder.com/practice/5daab034da954f5697dcf96c1808d34f?tpId=386&tqId=11262447&sourceUrl=%2Fexam%2Foj%3FquestionJobId%3D10%26subTabName%3Donline_coding_page)（来源：牛客（newcoder））
>
> 给定一个长度为 𝑛*n* 的正整数序列 {𝑎1,𝑎2,…,𝑎𝑛}{*a*1,*a*2,…,*a**n*} 。接下来有 𝑞*q* 次独立查询，第 𝑗*j* 次查询给出一对下标 𝑙𝑗,𝑟𝑗*l**j*,*r**j* ，请你计算区间乘积
>
> 第一行输入两个整数 𝑛,𝑞(1≦𝑛,𝑞≦105)*n*,*q*(1≦*n*,*q*≦105) ，分别表示序列长度与查询数量。
> 第二行输入 𝑛*n* 个整数 𝑎1,𝑎2,…,𝑎𝑛(1≦𝑎𝑖<109+7)*a*1,*a*2,…,*a*n*(1≦*a*i*<109+7) ，表示序列元素。
> 此后 *q* 行，第 𝑗*j* 行输入两个整数 𝑙𝑗,𝑟𝑗(1≦𝑙𝑗≦𝑟𝑗≦𝑛)*l*j*,*r*j*(1≦*lj*≦*r*j*≦*n*) ，表示一次查询的左右端点。
>
> 输入：
>
> 5 3
> 1 2 3 4 5
> 1 2
> 1 3
> 2 5
>
> 输出：2 6 120



> 用前缀积来求，以及逆元的知识来求
>
> 模运算中不能直接用除法，需要用**乘法逆元**替代。对于质数 `MOD`，根据**费马小定理**，`a` 的逆元为 `a^(MOD-2) % MOD`。
>
>  `a^(MOD-2) % MOD`最快的方法是用快速幂来求。

```java
import java.util.Scanner;

// 注意类名必须为 Main, 不要有任何 package xxx 信息
public class Main {
    static int mod=1000000007;
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        
        // 注意 hasNext 和 hasNextLine 的区别
        int n=in.nextInt();
        int q=in.nextInt();
        long nums[]=new long[n+1];
        nums[0]=1;
        for(int i=1;i<=n;i++){
          long num=in.nextLong();
            nums[i]=nums[i-1]*num%mod;
        }
        for(int i=0;i<q;i++){
        int l=in.nextInt();
        int r=in.nextInt();
        long res=nums[r]*pow(nums[l-1],mod-2)%mod;
        System.out.print(res+" ");
        }
    }
   static long pow(long a, long b) {
    long res = 1; // 结果初始值为1
    while (b > 0) {
        if (b % 2 == 1) { // 若指数为奇数，将当前底数乘入结果
            res = res * a % mod;
        }
        a = a * a % mod; // 底数平方（指数折半）
        b /= 2; // 指数折半
    }
    return res;
}
}
```

