[分割序列](https://www.nowcoder.com/practice/f49a64748c2344c1be65f9be417a495a?tpId=386&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj)（牛客）

> ## 描述
>
> 给定一个长度为 𝑛*n* 的 0101 串 𝑠*s*，你需要把它完全切分成若干连续子串 {𝑡𝑖}{*t**i*}，使得：
>
> 1. 1.​对于任意的连续子段 𝑡𝑖*t**i*​，命题 “该连续子段 𝑡𝑖*t**i*​ 内 **恰好** 包含一个数字字符 11” 恒成立。
>
> 2. 2.​ ∑𝑖=1∣𝑠∣𝑡𝑖=𝑠∑*i*=1∣*s*∣​*t**i*​=*s*，即这些切分后的连续子串按切分顺序拼接起来后恰好能得到原字符串 𝑠*s*。
>
> 
>
> 你需要求出满足以上两个要求的切分方案的总数量。由于最终的计算结果可能很大，你只需要输出这个结果对 (109+7)(109+7) 取模后的结果即可。
>
> ### 输入描述：
>
> 在一行上输入一个整数 𝑛(1≦𝑛≦105)*n*(1≦*n*≦105)。
> 在第二行上输入一个长度为 𝑛*n* 的 0101 串 𝑠*s* (𝑠𝑖∈{0,1})(*s**i*​∈{0,1})。
>
> ### 输出描述：
>
> 输出一个整数，表示满足要求的切分方案数量对 (109+7)(109+7) 取模后的结果。
>
> 输入：
>
> ```
> 5
> 10001
> ```
>
> 输出：
>
> ```
> 4
> ```
>
> 说明：
>
> ```
> 两数 11 之间有 33 个 00，可以在 44 个相邻的空隙中任选一个位置切分：
> ∙ ∙`1 | 0 0 0 1`
> ∙ ∙`1 0 | 0 0 1`
> ∙ ∙`1 0 0 | 0 1`
> ∙ ∙`1 0 0 0 | 1`
> 故共有 44 种切分方案。
> ```

> ```java
> 
> import java.util.*;
> 
> // 注意类名必须为 Main, 不要有任何 package xxx 信息
> public class Main {
>     static int mod=1000000007;
>     public static void main(String[] args) {
>         Scanner in = new Scanner(System.in);
>       int n=in.nextInt();
>       String str=in.next();
>       List<Integer>list=new ArrayList<>();
>       for(int i=0;i<n;i++){
>         if(str.charAt(i)=='1'){
>             list.add(i);
>         }
>       }
>       if(list.isEmpty()){
>         System.out.println(0);
>       }else{
>         long ans=1;
>         for(int i=0;i<list.size()-1;i++){
>             ans=(ans*(list.get(i+1)-list.get(i)))%mod;
>            
>         } System.out.println(ans);
>       }
>     }
> }
> 
> ```

> 这题主要是看清，每个子序列中**恰好**包含一个1，然后便是求字符串中‘1’的个数，相邻两个‘1’之间可以切割的个数就是相邻两个‘1’的距离。由于每次切分的选择是相互独立的，根据乘法原理，总的方案数就是所有相邻 `1` 之间切分选择数量的乘积。